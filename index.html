<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solfege Hero</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB, #98D8E8);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }

        #gameContainer {
            position: relative;
            margin: 10px auto; /* Reduced top margin */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            max-width: 100%; /* Ensure canvas is responsive */
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: clamp(14px, 3vw, 18px); /* Responsive font size */
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            z-index: 10;
        }

        #gameControls { /* Changed from #controls / #gameButtons */
            margin-top: 10px;
            text-align: center;
        }

        button { /* General button styling */
            margin: 5px;
            padding: 10px 15px;
            font-size: clamp(12px, 2.5vw, 16px);
            font-weight: bold;
            color: white;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #touchControlsContainer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 15px;
            width: 85%;
            max-width: 280px;
            margin-top: 15px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            position: relative;
        }

        .touch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s ease;
        }

        #touchLeftBtn, #touchRightBtn {
            background-color: #2196F3;
            color: white;
            border: 3px solid #1976D2;
            border-radius: 15px;
            width: clamp(50px, 14vw, 65px);
            height: clamp(40px, 12vw, 50px);
            font-size: clamp(16px, 4.5vw, 20px);
            box-shadow: 0 4px #1565C0;
        }

        #touchLeftBtn:active, #touchRightBtn:active {
            transform: translateY(2px);
            box-shadow: 0 2px #1565C0;
        }

        #touchJumpBtn {
            background-color: #4CAF50;
            color: white;
            border: 3px solid #388E3C;
            border-radius: 50%;
            width: clamp(60px, 16vw, 75px);
            height: clamp(60px, 16vw, 75px);
            font-size: clamp(22px, 6vw, 28px);
            box-shadow: 0 5px #2E7D32;
            position: relative;
            top: -10px; /* Raise jump button higher */
        }

        #touchJumpBtn:active {
            transform: translateY(2px);
            box-shadow: 0 3px #2E7D32;
            top: -8px;
        }

        /* Add finger-friendly touch indicators */
        #touchLeftBtn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 13px;
            pointer-events: none;
        }

        #touchRightBtn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 13px;
            pointer-events: none;
        }

        #touchJumpBtn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 2px solid rgba(76, 175, 80, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            padding: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            z-index: 100;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
         #instructions.hidden {
            opacity: 0;
            transform: translate(-50%, -60%);
            pointer-events: none;
        }

        #instructions h2 { margin-top: 0; }
        #closeInstructionsBtn {
            position: absolute; top: 10px; right: 10px; background: #ff6b6b;
            color: white; border: none; border-radius: 50%; width: 30px; height: 30px;
            font-size: 18px; font-weight: bold; line-height: 30px; text-align: center;
            cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
         #closeInstructionsBtn:hover { background: #e74c3c; }

        h1 {
            color: #333; text-align: center; margin-bottom: 10px;
             font-size: clamp(24px, 5vw, 32px);
        }
        .note-legend {
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 5px; margin-top: 10px;
        }
        .note-box {
            padding: 3px 8px; border-radius: 5px; font-weight: bold; color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); font-size: clamp(10px, 2vw, 12px);
        }
    </style>
</head>
<body>
    <h1>ðŸŽµ Solfege Hero ðŸŽµ</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>Song: <span id="songName">-</span></div>
            <div id="progress" style="margin-top: 5px;">Progress: <span id="progressText">0/0</span></div>
        </div>
    </div>

    <div id="touchControlsContainer">
        <div class="touch-btn" id="touchLeftBtn">â—€</div>
        <div class="touch-btn" id="touchJumpBtn">â–²</div>
        <div class="touch-btn" id="touchRightBtn">â–¶</div>
    </div>

    <div id="gameControls"> <!-- ID Changed -->
        <button id="startBtn">Start Game</button>
        <button id="restartLevelBtn">Restart Level</button>
        <button id="restartGameBtn">Restart Game</button>
    </div>

    <div id="instructions">
        <button id="closeInstructionsBtn">âœ–</button>
        <h2>How to Play:</h2>
        <p>1. Listen carefully to the nursery rhyme at the beginning of each level.</p>
        <p>2. Remember the melody and recreate it by jumping on the colored blocks.</p>
        <p>3. Use Arrow Keys or on-screen buttons to move left/right and Spacebar or â–² to jump.</p>
        <p>4. No hints mid-song! Trust your memory and ears.</p>
        <p>5. You can restart the level to hear the song again if needed.</p>

        <div class="note-legend">
            <div class="note-box" style="background: #FF0000;">C</div>
            <div class="note-box" style="background: #FF7F00;">D</div>
            <div class="note-box" style="background: #FFFF00; color: #333;">E</div>
            <div class="note-box" style="background: #00FF00; color: #333;">F</div>
            <div class="note-box" style="background: #0000FF;">G</div>
            <div class="note-box" style="background: #4B0082;">A</div>
            <div class="note-box" style="background: #9400D3;">B</div>
            <div class="note-box" style="background: #FF0000;">c</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const instructionsPanel = document.getElementById('instructions');
        const closeInstructionsBtn = document.getElementById('closeInstructionsBtn');
        let instructionsTimeout;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const notes = {
            'C': { freq: 261.63, color: '#FF0000', name: 'Do' },
            'D': { freq: 293.66, color: '#FF7F00', name: 'Re' },
            'E': { freq: 329.63, color: '#FFFF00', name: 'Mi' },
            'F': { freq: 349.23, color: '#00FF00', name: 'Fa' },
            'G': { freq: 392.00, color: '#0000FF', name: 'Sol' },
            'A': { freq: 440.00, color: '#4B0082', name: 'La' },
            'B': { freq: 493.88, color: '#9400D3', name: 'Ti' },
            'c': { freq: 523.25, color: '#FF0000', name: 'Do (high)' }
        };
const songs = [
    {
        name: "Jingle Bells",
        notes: [
            {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'half'},
            {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'half'},
            {note: 'E', duration: 'quarter'}, {note: 'G', duration: 'quarter'}, {note: 'C', duration: 'dotted_quarter'}, {note: 'D', duration: 'eighth'}, {note: 'E', duration: 'whole'},
            {note: 'F', duration: 'quarter'}, {note: 'F', duration: 'quarter'}, {note: 'F', duration: 'dotted_quarter'}, {note: 'F', duration: 'eighth'},
            {note: 'F', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'eighth'}, {note: 'E', duration: 'eighth'},
            {note: 'G', duration: 'quarter'}, {note: 'G', duration: 'quarter'}, {note: 'F', duration: 'quarter'}, {note: 'D', duration: 'quarter'}, {note: 'C', duration: 'half'}
        ],
        tempo: 380
    },
    {
        name: "London Bridge",
        notes: [
            {note: 'G', duration: 'dotted_quarter'}, {note: 'A', duration: 'eighth'}, {note: 'G', duration: 'quarter'}, {note: 'F', duration: 'quarter'},
            {note: 'E', duration: 'quarter'}, {note: 'F', duration: 'quarter'}, {note: 'G', duration: 'half'},
            {note: 'G', duration: 'dotted_quarter'}, {note: 'A', duration: 'eighth'}, {note: 'G', duration: 'quarter'}, {note: 'F', duration: 'quarter'},
            {note: 'E', duration: 'quarter'}, {note: 'F', duration: 'quarter'}, {note: 'G', duration: 'half'}
        ],
        tempo: 400
    },
    {
        name: "Mary Had a Little Lamb",
        notes: [
            {note: 'E', duration: 'dotted_quarter'}, {note: 'D', duration: 'eighth'}, {note: 'C', duration: 'quarter'}, {note: 'D', duration: 'quarter'},
            {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'half'},
            {note: 'D', duration: 'quarter'}, {note: 'D', duration: 'quarter'}, {note: 'D', duration: 'half'},
            {note: 'E', duration: 'quarter'}, {note: 'G', duration: 'quarter'}, {note: 'G', duration: 'half'}
        ],
        tempo: 400
    },
    {
        name: "Old MacDonald",
        notes: [
            {note: 'G', duration: 'quarter'}, {note: 'G', duration: 'quarter'}, {note: 'G', duration: 'quarter'}, {note: 'D', duration: 'quarter'},
            {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'D', duration: 'half'},
            {note: 'B', duration: 'quarter'}, {note: 'B', duration: 'quarter'}, {note: 'A', duration: 'quarter'}, {note: 'A', duration: 'quarter'},
            {note: 'G', duration: 'half'}
        ],
        tempo: 400
    },
    {
        name: "Pop Goes the Weasel",
        notes: [
            {note: 'C', duration: 'eighth'}, {note: 'D', duration: 'eighth'}, {note: 'E', duration: 'quarter'}, {note: 'C', duration: 'quarter'},
            {note: 'E', duration: 'eighth'}, {note: 'F', duration: 'eighth'}, {note: 'G', duration: 'half'},
            {note: 'G', duration: 'eighth'}, {note: 'A', duration: 'eighth'}, {note: 'G', duration: 'quarter'}, {note: 'F', duration: 'quarter'},
            {note: 'E', duration: 'eighth'}, {note: 'C', duration: 'eighth'}, {note: 'D', duration: 'quarter'}, {note: 'C', duration: 'half'}
        ],
        tempo: 400
    },
    {
        name: "Row Row Row Your Boat",
        notes: [
            {note: 'C', duration: 'quarter'}, {note: 'C', duration: 'quarter'}, {note: 'C', duration: 'dotted_quarter'}, {note: 'D', duration: 'eighth'},
            {note: 'E', duration: 'half'},
            {note: 'E', duration: 'dotted_quarter'}, {note: 'D', duration: 'eighth'}, {note: 'E', duration: 'dotted_quarter'}, {note: 'F', duration: 'eighth'},
            {note: 'G', duration: 'half'},
            {note: 'c', duration: 'eighth'}, {note: 'c', duration: 'eighth'}, {note: 'c', duration: 'eighth'},
            {note: 'G', duration: 'eighth'}, {note: 'G', duration: 'eighth'}, {note: 'G', duration: 'eighth'},
            {note: 'E', duration: 'eighth'}, {note: 'E', duration: 'eighth'}, {note: 'E', duration: 'eighth'},
            {note: 'C', duration: 'eighth'}, {note: 'C', duration: 'eighth'}, {note: 'C', duration: 'eighth'}
        ],
        tempo: 420
    },
    {
        name: "Twinkle Twinkle",
        notes: [
            {note: 'C', duration: 'quarter'}, {note: 'C', duration: 'quarter'}, {note: 'G', duration: 'quarter'}, {note: 'G', duration: 'quarter'},
            {note: 'A', duration: 'quarter'}, {note: 'A', duration: 'quarter'}, {note: 'G', duration: 'half'},
            {note: 'F', duration: 'quarter'}, {note: 'F', duration: 'quarter'}, {note: 'E', duration: 'quarter'}, {note: 'E', duration: 'quarter'},
            {note: 'D', duration: 'quarter'}, {note: 'D', duration: 'quarter'}, {note: 'C', duration: 'half'}
        ],
        tempo: 500
    }
];
        let gameState = { started: false, level: 0, score: 0, currentSong: null, currentNoteIndex: 0, noteSequence: [], levelComplete: false, lastCorrectNote: null };
        const player = {
            x: 50, y: 0, width: 60, height: 60,
            vx: 0, vy: 0, speed: 2.8, jumpPower: -16,
            grounded: false, color: '#FF6B6B', eyeFrame: 0, direction: 1
        };
        const particles = [];
        let clouds = [];
        let birds = [];
        let magicalCreatures = [];

        class Cloud {
            constructor() {
                this.x = canvas.width + Math.random() * 200;
                this.y = Math.random() * (canvas.height * 0.4) + 20;
                this.size = Math.random() * 40 + 30;
                this.speed = Math.random() * 0.2 + 0.1; // Slower for relaxing effect
                this.opacity = Math.random() * 0.3 + 0.1;
            }

            update() {
                this.x -= this.speed;
                if (this.x + this.size < 0) {
                    this.x = canvas.width + Math.random() * 200;
                    this.y = Math.random() * (canvas.height * 0.4) + 20;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = 'white';

                // Draw cloud as overlapping circles
                const circles = [
                    {x: 0, y: 0, r: this.size * 0.6},
                    {x: this.size * 0.4, y: -this.size * 0.1, r: this.size * 0.5},
                    {x: -this.size * 0.3, y: -this.size * 0.1, r: this.size * 0.4},
                    {x: this.size * 0.1, y: -this.size * 0.3, r: this.size * 0.3}
                ];

                circles.forEach(circle => {
                    ctx.beginPath();
                    ctx.arc(this.x + circle.x, this.y + circle.y, circle.r, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        class Bird {
            constructor() {
                this.x = canvas.width + Math.random() * 100;
                this.y = Math.random() * (canvas.height * 0.6) + 50;
                this.speed = Math.random() * 0.8 + 0.5; // Slower and more relaxing
                this.wingPhase = Math.random() * Math.PI * 2;
                this.size = Math.random() * 8 + 6;
                this.bobAmount = Math.random() * 2 + 1;
            }

            update() {
                this.x -= this.speed;
                this.wingPhase += 0.3;
                if (this.x < -50) {
                    this.x = canvas.width + Math.random() * 200;
                    this.y = Math.random() * (canvas.height * 0.6) + 50;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = '#333';

                const wingOffset = Math.sin(this.wingPhase) * this.bobAmount;
                const bodyY = this.y + Math.sin(this.wingPhase * 0.5) * 0.5;

                // Draw bird body
                ctx.beginPath();
                ctx.ellipse(this.x, bodyY, this.size * 0.6, this.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw wings
                ctx.beginPath();
                ctx.ellipse(this.x - this.size * 0.3, bodyY + wingOffset, this.size * 0.4, this.size * 0.2, -0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse(this.x + this.size * 0.3, bodyY + wingOffset, this.size * 0.4, this.size * 0.2, 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class MagicalCreature {
            constructor(type = 'unicorn') {
                this.type = type;
                this.x = canvas.width + Math.random() * 150;
                this.y = Math.random() * (canvas.height * 0.5) + 30;
                this.speed = Math.random() * 0.6 + 0.3;
                this.wingPhase = Math.random() * Math.PI * 2;
                this.size = Math.random() * 12 + 15;
                this.sparklePhase = Math.random() * Math.PI * 2;
                this.trailParticles = [];
                this.hornGlow = 0;
            }

            update() {
                this.x -= this.speed;
                this.wingPhase += 0.15;
                this.sparklePhase += 0.1;
                this.hornGlow = Math.sin(this.sparklePhase) * 0.5 + 0.5;

                // Add magical trail
                if (Math.random() < 0.3) {
                    this.trailParticles.push({
                        x: this.x - this.size * 0.5,
                        y: this.y + Math.random() * 10 - 5,
                        color: `hsl(${(Date.now() * 0.1 + Math.random() * 60) % 360}, 80%, 70%)`,
                        life: 30,
                        size: Math.random() * 3 + 2
                    });
                }

                // Update trail particles
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    this.trailParticles[i].life--;
                    this.trailParticles[i].size *= 0.95;
                    if (this.trailParticles[i].life <= 0) {
                        this.trailParticles.splice(i, 1);
                    }
                }

                if (this.x < -100) {
                    this.x = canvas.width + Math.random() * 300 + 200; // Less frequent appearances
                    this.y = Math.random() * (canvas.height * 0.5) + 30;
                }
            }

            draw(ctx) {
                // Draw magical trail
                this.trailParticles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life / 30;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                ctx.save();
                if (this.type === 'unicorn') {
                    // Unicorn body (white/pink)
                    ctx.fillStyle = '#F8BBD9';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, this.size * 0.8, this.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Unicorn head
                    ctx.fillStyle = '#FFE4E1';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.size * 0.6, this.y - this.size * 0.2, this.size * 0.4, this.size * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Horn with rainbow glow
                    ctx.save();
                    ctx.shadowColor = `hsl(${(this.sparklePhase * 50) % 360}, 100%, 60%)`;
                    ctx.shadowBlur = 8 + this.hornGlow * 5;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size * 0.8, this.y - this.size * 0.5);
                    ctx.lineTo(this.x + this.size * 0.7, this.y - this.size * 0.8);
                    ctx.lineTo(this.x + this.size * 0.9, this.y - this.size * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();

                    // Wings with flapping
                    const wingOffset = Math.sin(this.wingPhase) * this.size * 0.3;
                    ctx.fillStyle = '#E6E6FA';
                    ctx.beginPath();
                    ctx.ellipse(this.x - this.size * 0.2, this.y - this.size * 0.1 + wingOffset, this.size * 0.6, this.size * 0.4, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.x - this.size * 0.2, this.y + this.size * 0.1 - wingOffset, this.size * 0.6, this.size * 0.4, 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Magical mane
                    const colors = ['#FF69B4', '#87CEEB', '#98FB98', '#DDA0DD'];
                    colors.forEach((color, i) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        const maneOffset = Math.sin(this.sparklePhase + i) * 3;
                        ctx.ellipse(this.x + this.size * 0.3, this.y - this.size * 0.3 + maneOffset, this.size * 0.2, this.size * 0.1, 0, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                ctx.restore();
            }
        }

        function initializeBackground() {
            clouds = [];
            birds = [];
            magicalCreatures = [];

            // Create initial clouds
            for (let i = 0; i < 4; i++) {
                const cloud = new Cloud();
                cloud.x = Math.random() * canvas.width;
                clouds.push(cloud);
            }

            // Create initial birds
            for (let i = 0; i < 2; i++) { // Fewer regular birds
                const bird = new Bird();
                bird.x = Math.random() * canvas.width;
                birds.push(bird);
            }

            // Create magical creatures (unicorns)
            for (let i = 0; i < 1; i++) {
                const creature = new MagicalCreature('unicorn');
                creature.x = Math.random() * canvas.width;
                magicalCreatures.push(creature);
            }
        }

        class Particle { /* ... Same Particle class ... */
            constructor(x, y, color, sizeMultiplier = 1, lifeMultiplier = 1, isFireworkRocket = false) {
                this.x = x; this.y = y; this.isFireworkRocket = isFireworkRocket;
                if (this.isFireworkRocket) {
                    this.vx = (Math.random() - 0.5) * 2; this.vy = -Math.random() * 3 - 4;
                    this.targetY = canvas.height * (Math.random() * 0.3 + 0.1);
                    this.color = color || `hsl(${Math.random() * 360}, 100%, 70%)`; this.size = 4 * sizeMultiplier;
                } else {
                    this.vx = (Math.random() - 0.5) * 8 * (sizeMultiplier * 0.5);
                    this.vy = (Math.random() - 0.7) * 8 * (sizeMultiplier * 0.5);
                    this.color = color || `hsl(${Math.random() * 360}, 100%, 70%)`;
                    this.size = (Math.random() * 6 + 4) * sizeMultiplier;
                }
                this.life = (this.isFireworkRocket ? 120 : 60) * lifeMultiplier; this.initialLife = this.life;
                this.decay = 0.015 / lifeMultiplier; this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (!this.isFireworkRocket) { this.vy += 0.2; }
                this.life -= 1; this.rotation += this.rotationSpeed;
                if (!this.isFireworkRocket) { this.size *= 0.98; }
                if (this.isFireworkRocket && this.y <= this.targetY) {
                    this.life = 0; createStarBurst(this.x, this.y, 50 + Math.random() * 50, this.color, 1.5, 1.5, false);
                }
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life / this.initialLife);
                ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.fillStyle = this.color;
                if (this.isFireworkRocket) {
                    ctx.beginPath(); ctx.arc(0,0, this.size/2, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha *= 0.5; ctx.beginPath(); ctx.arc(0, this.size * 0.8, this.size/3, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2 + this.rotation;
                        const x = Math.cos(angle) * this.size; const y = Math.sin(angle) * this.size;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        const innerAngle = angle + Math.PI / 5;
                        const innerX = Math.cos(innerAngle) * (this.size * 0.5); const innerY = Math.sin(innerAngle) * (this.size * 0.5);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath(); ctx.fill();
                }
                ctx.restore();
            }
        }
        function createStarBurst(x,y,c=20,bc=null,sm=1,lm=1,ir=false){for(let i=0;i<c;i++){particles.push(new Particle(x,y,bc?lightenColor(bc,Math.random()*30):`hsl(${Math.random()*360},100%,70%)`,sm,lm,ir))}}

        function createNoteHitEffect(x, y, color) {
            // Create enhanced particle effect for correct notes
            for (let i = 0; i < 25; i++) {
                const particle = new Particle(x, y, color, 0.8, 1.2);
                particle.vx = (Math.random() - 0.5) * 12;
                particle.vy = (Math.random() - 0.8) * 10;
                particles.push(particle);
            }

            // Add some sparkling stars
            for (let i = 0; i < 15; i++) {
                const sparkle = new Particle(x, y, '#FFD700', 0.6, 1.5);
                sparkle.vx = (Math.random() - 0.5) * 8;
                sparkle.vy = (Math.random() - 0.6) * 8;
                particles.push(sparkle);
            }
        }
        function triggerFireworksShow(){
            for(let i=0;i<8+Math.floor(Math.random()*5);i++){
                setTimeout(()=>{
                    const x = Math.random()*(canvas.width*.8)+(canvas.width*.1);
                    const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                    const color = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
                    createStarBurst(x, canvas.height, 1, color, 1, 1, true);

                    // Add extra rainbow sparkles for level completion
                    setTimeout(() => {
                        for(let j = 0; j < 15; j++) {
                            const sparkle = new Particle(x, canvas.height * 0.3,
                                `hsl(${Math.random() * 360}, 100%, 70%)`, 1.2, 2);
                            sparkle.vx = (Math.random() - 0.5) * 10;
                            sparkle.vy = (Math.random() - 0.8) * 8;
                            particles.push(sparkle);
                        }
                    }, 200);
                }, i*(250+Math.random()*150));
            }
        }

        let blocks = []; let platforms = []; const keys = {};

        function setCanvasSize() {
            // Calculate minimum width needed for all blocks
            const minWidthForBlocks = (8 * 80) + (7 * 40) + 40; // 8 blocks, 7 gaps, plus margins = 960px
            const aspectRatio = 800 / 600;
            const availableWidth = Math.max(minWidthForBlocks, window.innerWidth * 0.95);
            const availableHeight = window.innerHeight * 0.65;
            let newWidth, newHeight;

            // Prioritize fitting all blocks, then maintain aspect ratio if possible
            if (availableWidth >= minWidthForBlocks) {
                if (availableWidth / availableHeight > aspectRatio) {
                    newHeight = availableHeight;
                    newWidth = Math.max(minWidthForBlocks, newHeight * aspectRatio);
                } else {
                    newWidth = availableWidth;
                    newHeight = newWidth / aspectRatio;
                }
            } else {
                newWidth = minWidthForBlocks;
                newHeight = newWidth / aspectRatio;
            }

            canvas.width = Math.max(minWidthForBlocks, newWidth);
            canvas.height = Math.max(240, newHeight);
            player.y = canvas.height - player.height - 50;
            createLevel(gameState.level > 0 ? gameState.level -1 : 0);
            initializeBackground();
            if(gameState.started) draw(); else { draw(); drawStartScreenOverlay(); }
        }
        window.addEventListener('resize', setCanvasSize);

        document.addEventListener('keydown',(e)=>{keys[e.key]=true;if(e.key===' ')e.preventDefault();});
        document.addEventListener('keyup',(e)=>{keys[e.key]=false;});
        const touchLeftBtn=document.getElementById('touchLeftBtn'),touchRightBtn=document.getElementById('touchRightBtn'),touchJumpBtn=document.getElementById('touchJumpBtn');
        function handleTouchStart(k){keys[k]=true} function handleTouchEnd(k){keys[k]=false}
        touchLeftBtn.addEventListener('touchstart',(e)=>{e.preventDefault();handleTouchStart('ArrowLeft')},{passive:false});
        touchLeftBtn.addEventListener('touchend',(e)=>{e.preventDefault();handleTouchEnd('ArrowLeft')});
        touchLeftBtn.addEventListener('mousedown',()=>handleTouchStart('ArrowLeft'));touchLeftBtn.addEventListener('mouseup',()=>handleTouchEnd('ArrowLeft'));
        touchRightBtn.addEventListener('touchstart',(e)=>{e.preventDefault();handleTouchStart('ArrowRight')},{passive:false});
        touchRightBtn.addEventListener('touchend',(e)=>{e.preventDefault();handleTouchEnd('ArrowRight')});
        touchRightBtn.addEventListener('mousedown',()=>handleTouchStart('ArrowRight'));touchRightBtn.addEventListener('mouseup',()=>handleTouchEnd('ArrowRight'));
        touchJumpBtn.addEventListener('touchstart',(e)=>{e.preventDefault();handleTouchStart(' ')},{passive:false});
        touchJumpBtn.addEventListener('touchend',(e)=>{e.preventDefault();handleTouchEnd(' ')});
        touchJumpBtn.addEventListener('mousedown',()=>handleTouchStart(' '));touchJumpBtn.addEventListener('mouseup',()=>handleTouchEnd(' '));

        document.getElementById('startBtn').addEventListener('click',startGame);
        document.getElementById('restartLevelBtn').addEventListener('click',restartLevel);
        document.getElementById('restartGameBtn').addEventListener('click',restartGame);
        closeInstructionsBtn.addEventListener('click',hideInstructions);

        function hideInstructions(){clearTimeout(instructionsTimeout);instructionsPanel.classList.add('hidden')}
        function showInstructions(){instructionsPanel.classList.remove('hidden');clearTimeout(instructionsTimeout);instructionsTimeout=setTimeout(hideInstructions,12000)}

        function playNote(nk,d=200){if(!notes[nk])return;const o=audioContext.createOscillator(),g=audioContext.createGain();o.connect(g);g.connect(audioContext.destination);o.frequency.value=notes[nk].freq;o.type='sine';g.gain.setValueAtTime(.2,audioContext.currentTime);g.gain.exponentialRampToValueAtTime(.01,audioContext.currentTime+d/1000);o.start(audioContext.currentTime);o.stop(audioContext.currentTime+d/1000)}

        const durationMultipliers = {
            'sixteenth': 0.25,
            'eighth': 0.5,
            'quarter': 1,
            'dotted_quarter': 1.5,
            'half': 2,
            'whole': 4
        };

        async function playSong(s) {
            for (let i = 0; i < s.notes.length; i++) {
                const noteObj = s.notes[i];

                // Handle songs that might still use the old string format for notes
                if (typeof noteObj === 'string') {
                    playNote(noteObj, s.tempo * 0.8); // Default old behavior
                    await new Promise(r => setTimeout(r, s.tempo));
                } else {
                    const noteName = noteObj.note;
                    const durationName = noteObj.duration;

                    let multiplier = durationMultipliers[durationName];
                    if (multiplier === undefined) {
                        console.warn(`Unknown duration: ${durationName}, defaulting to quarter note (multiplier 1).`);
                        multiplier = 1;
                    }

                    const noteDurationMs = s.tempo * multiplier;

                    playNote(noteName, noteDurationMs);
                    await new Promise(r => setTimeout(r, noteDurationMs));
                }
            }
        }

        function createLevel(levelIndex) {
            blocks = []; platforms = [];
            const groundY = canvas.height - 50;
            platforms.push({ x: 0, y: groundY, width: canvas.width, height: 50 });

            const blockYPosition = canvas.height - player.height - 180; // Blocks raised higher

            const notePlatformWidth = Math.min(850, canvas.width * 0.95);
            const notePlatformX = (canvas.width - notePlatformWidth) / 2;

            const allNoteKeys = Object.keys(notes);
            const blockCount = allNoteKeys.length;
            const blockWidth = 80; // Fixed width - no longer responsive
            const totalBlockActualWidth = blockCount * blockWidth;
            const desiredGap = 40; // Fixed spacing
            const totalDesiredGapWidth = (blockCount - 1) * desiredGap;
            const totalRequiredWidth = totalBlockActualWidth + totalDesiredGapWidth;

            let startX; let actualBlockSpacing;

            // Always use fixed spacing - center the blocks if there's extra space
            actualBlockSpacing = desiredGap;
            startX = (canvas.width - totalRequiredWidth) / 2;

            // Ensure blocks don't go off screen on very small displays
            if (startX < 10) {
                startX = 10;
            }

            allNoteKeys.forEach((noteKey, index) => {
                blocks.push({
                    x: startX + index * (blockWidth + actualBlockSpacing),
                    y: blockYPosition,
                    width: blockWidth, height: player.height,
                    note: noteKey, color: notes[noteKey].color,
                    hit: false, lastHit: 0
                });
            });
        }

        async function startGame() {
            if (audioContext.state === 'suspended') await audioContext.resume();
            gameState.started = true; gameState.level = 1; gameState.score = 0;
            gameState.currentSong = songs[0]; gameState.noteSequence = [...gameState.currentSong.notes];
            gameState.currentNoteIndex = 0; gameState.levelComplete = false; particles.length = 0;
            setCanvasSize(); updateUI();
            document.getElementById('songName').textContent = gameState.currentSong.name;
            await playSong(gameState.currentSong); gameLoop();
        }

        async function restartLevel() {
            if(!gameState.started)return;if(audioContext.state==='suspended')await audioContext.resume();
            gameState.currentNoteIndex=0;gameState.levelComplete=false;gameState.lastCorrectNote=null;particles.length=0;
            player.x=50;player.y=canvas.height-player.height-50;player.vx=0;player.vy=0;
            blocks.forEach(b=>b.lastHit=0);updateUI();await playSong(gameState.currentSong);
        }
        async function restartGame() {
            if(audioContext.state==='suspended')await audioContext.resume();
            gameState={started:false,level:0,score:0,currentSong:null,currentNoteIndex:0,noteSequence:[],levelComplete:false};
            player.x=50;player.y=canvas.height-player.height-50;player.vx=0;player.vy=0;
            blocks=[];platforms=[];particles.length=0;updateUI();await startGame();
        }
        function updateUI(){
            document.getElementById('score').textContent=gameState.score;document.getElementById('level').textContent=gameState.level;
            document.getElementById('songName').textContent=gameState.currentSong?gameState.currentSong.name:"-";
            const p=gameState.currentSong?gameState.currentNoteIndex+'/'+gameState.noteSequence.length:"0/0";
            document.getElementById('progressText').textContent=p;
            if(gameState.currentSong&&gameState.currentNoteIndex>=gameState.noteSequence.length){document.getElementById('progressText').textContent='Complete!'}
        }

        function checkCollision(r1,r2){return r1.x<r2.x+r2.width&&r1.x+r1.width>r2.x&&r1.y<r2.y+r2.height&&r1.y+r1.height>r2.y}

        function updatePlayer() {
            if (!gameState.started || gameState.levelComplete) return;
            if (keys['ArrowLeft']) { player.vx = -player.speed; player.direction = -1; }
            else if (keys['ArrowRight']) { player.vx = player.speed; player.direction = 1; }
            else { player.vx *= 0.9; }
            if (keys[' '] && player.grounded) { player.vy = player.jumpPower; player.grounded = false; }

            let prevY = player.y;
            player.vy += 0.5;
            player.y += player.vy;
            player.x += player.vx;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

            player.grounded = false;

            platforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    if (player.vy >= 0 && prevY + player.height <= platform.y + 1) {
                        player.y = platform.y - player.height; player.vy = 0; player.grounded = true;
                    }
                }
            });

            blocks.forEach(block => {
                if (checkCollision(player, block)) {
                    if (player.vy >= 0 && prevY + player.height <= block.y + 1) { // Landing on block
                        player.y = block.y - player.height; player.vy = 0; player.grounded = true;
                        playNote(block.note, 300); block.lastHit = Date.now();
                        if (gameState.currentNoteIndex < gameState.noteSequence.length && block.note === gameState.noteSequence[gameState.currentNoteIndex]) {
                            gameState.score += 100; gameState.currentNoteIndex++;
                            gameState.lastCorrectNote = block.note; // Track last correct note
                            createNoteHitEffect(block.x + block.width/2, block.y, block.color);
                            if (gameState.currentNoteIndex >= gameState.noteSequence.length) { gameState.levelComplete = true; triggerFireworksShow(); setTimeout(nextLevel, 4000); }
                        } else if (gameState.currentNoteIndex < gameState.noteSequence.length) { gameState.score = Math.max(0, gameState.score - 20); }
                        updateUI();
                    }
                    else if (player.vy < 0 && prevY >= block.y + block.height -1 ) { // Hit from below
                        player.y = block.y + block.height; player.vy = 2;
                        playNote(block.note, 300); block.lastHit = Date.now();
                        if (gameState.currentNoteIndex < gameState.noteSequence.length && block.note === gameState.noteSequence[gameState.currentNoteIndex]) {
                            gameState.score += 100; gameState.currentNoteIndex++;
                            gameState.lastCorrectNote = block.note; // Track last correct note
                            createNoteHitEffect(block.x + block.width/2, block.y, block.color);
                            if (gameState.currentNoteIndex >= gameState.noteSequence.length) { gameState.levelComplete = true; triggerFireworksShow(); setTimeout(nextLevel, 4000); }
                        } else if (gameState.currentNoteIndex < gameState.noteSequence.length) { gameState.score = Math.max(0, gameState.score - 20); }
                        updateUI();
                    }
                    else if (player.vx !== 0) {  // Horizontal collision with block side
                        if (player.vx > 0 && player.x + player.width > block.x && player.x < block.x) { // Moving right, hit left side
                            player.x = block.x - player.width; player.vx = 0;
                        } else if (player.vx < 0 && player.x < block.x + block.width && player.x + player.width > block.x + block.width) { // Moving left, hit right side
                            player.x = block.x + block.width; player.vx = 0;
                        }
                    }
                }
            });

            if (player.y > canvas.height + player.height) {
                player.x = 50; player.y = canvas.height - player.height - 50; player.vx = 0; player.vy = 0;
            }
            if (Math.abs(player.vx) > 0.1 || !player.grounded) { player.eyeFrame = (player.eyeFrame + 0.1) % (Math.PI * 2); }
            else { player.eyeFrame = (player.eyeFrame + 0.02) % (Math.PI * 2); }
        }

        async function nextLevel(){if(!gameState.started)return;gameState.level++;gameState.currentSong=songs[(gameState.level-1)%songs.length];gameState.noteSequence=[...gameState.currentSong.notes];gameState.currentNoteIndex=0;gameState.levelComplete=false;gameState.lastCorrectNote=null;particles.length=0;player.x=50;player.y=canvas.height-player.height-50;player.vx=0;player.vy=0;updateUI();document.getElementById('songName').textContent=gameState.currentSong.name;await playSong(gameState.currentSong);if(!gameLoopRequest)gameLoop()}

        function draw() {
            ctx.clearRect(0,0,canvas.width,canvas.height);

            // Draw background clouds (parallax effect)
            clouds.forEach(cloud => cloud.draw(ctx));

            // Draw birds
            birds.forEach(bird => bird.draw(ctx));

            // Draw magical creatures
            magicalCreatures.forEach(creature => creature.draw(ctx));

            // Draw static background clouds (keeping original ones)
            ctx.fillStyle='rgba(255,255,255,0.8)';
            [[100,100,30],[130,100,35],[160,100,30],[canvas.width-150,80,25],[canvas.width-125,80,30],[canvas.width-100,80,25]].forEach(c=>{ctx.beginPath();ctx.arc(c[0],c[1],c[2],0,Math.PI*2);ctx.fill()});
            platforms.forEach(p=>{ctx.fillStyle='#8B4513';ctx.fillRect(p.x,p.y,p.width,p.height);if(!p.isVisual){ctx.fillStyle='#228B22';ctx.fillRect(p.x,p.y,p.width,5)}});
            blocks.forEach(b=>{const ts=Date.now()-b.lastHit,ir=ts<300,s=ir?1+Math.sin(ts*.02)*.05:1,yo=ir?Math.sin(ts*.02)*-3:0;
            const isLastCorrect=gameState.lastCorrectNote===b.note;ctx.save();ctx.translate(b.x+b.width/2,b.y+b.height/2+yo);ctx.scale(s,s);
            if(isLastCorrect){ctx.shadowColor='#FFD700';ctx.shadowBlur=15+Math.sin(Date.now()*.008)*5;ctx.strokeStyle='#FFD700';ctx.lineWidth=3;ctx.strokeRect(-b.width/2-2,-b.height/2-2,b.width+4,b.height+4);ctx.shadowBlur=0}
            ctx.fillStyle='rgba(0,0,0,0.2)';ctx.fillRect(-b.width/2+3,-b.height/2+3,b.width,b.height);const g=ctx.createLinearGradient(-b.width/2,-b.height/2,-b.width/2,b.height/2),bc=b.color;g.addColorStop(0,lightenColor(bc,20));g.addColorStop(.5,bc);g.addColorStop(1,darkenColor(bc,15));ctx.fillStyle=g;ctx.fillRect(-b.width/2,-b.height/2,b.width,b.height);ctx.fillStyle='rgba(255,255,255,0.2)';ctx.fillRect(-b.width/2+4,-b.height/2+4,b.width-8,8);ctx.strokeStyle=darkenColor(bc,30);ctx.lineWidth=1.5;ctx.strokeRect(-b.width/2,-b.height/2,b.width,b.height);if(ir){ctx.shadowColor=b.color;ctx.shadowBlur=10+Math.sin(ts*.1)*5;ctx.strokeStyle=lightenColor(b.color,50);ctx.lineWidth=2;ctx.strokeRect(-b.width/2,-b.height/2,b.width,b.height);ctx.shadowBlur=0}
            const ndn=b.note;ctx.font=`bold ${b.height*.35}px Arial`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle='rgba(0,0,0,0.4)';ctx.fillText(ndn,1,1);ctx.fillStyle=(['E','F'].includes(b.note)&&b.color==='#FFFF00')||b.color==='#00FF00'?'#333':'white';ctx.fillText(ndn,0,0);ctx.restore()});
            ctx.save();ctx.fillStyle=player.color;ctx.fillRect(player.x+5,player.y+10,player.width-10,player.height-15);ctx.fillStyle='#FFDAB9';ctx.beginPath();ctx.arc(player.x+player.width/2,player.y+10,player.width/3,0,Math.PI*2);ctx.fill();ctx.fillStyle='#A0522D';ctx.beginPath();ctx.arc(player.x+player.width/2,player.y+5,player.width/3.5,Math.PI,0);ctx.fill();const ex=player.x+player.width/2+(player.direction*player.width/8),ey=player.y+8,es=player.width/8,ps=es/2;ctx.fillStyle='white';ctx.beginPath();ctx.arc(ex-player.width/6,ey,es,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(ex+player.width/6,ey,es,0,Math.PI*2);ctx.fill();ctx.fillStyle='black';const bf=Math.sin(player.eyeFrame)>.9?.2:1;ctx.beginPath();ctx.arc(ex-player.width/6,ey,ps,0,Math.PI*2*bf);ctx.fill();ctx.beginPath();ctx.arc(ex+player.width/6,ey,ps,0,Math.PI*2*bf);ctx.fill();ctx.strokeStyle='black';ctx.lineWidth=1;ctx.beginPath();const my=player.y+15;if(player.grounded&&Math.abs(player.vx)<.1){ctx.arc(player.x+player.width/2,my,player.width/8,.2*Math.PI,.8*Math.PI)}else{ctx.arc(player.x+player.width/2,my+2,player.width/7,0,Math.PI*2)}
            ctx.stroke();ctx.fillStyle='#4682B4';const lsw=player.grounded&&Math.abs(player.vx)>.1?Math.sin(Date.now()*.01*player.speed)*player.width/8:0;ctx.fillRect(player.x+player.width/2-player.width/4-2-lsw,player.y+player.height-10,player.width/4,10);ctx.fillRect(player.x+player.width/2+2+lsw,player.y+player.height-10,player.width/4,10);ctx.restore();
            particles.forEach(p=>p.draw(ctx));
            if(gameState.levelComplete&&!particles.some(p=>p.isFireworkRocket||p.life>p.initialLife*.8)){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(canvas.width/2-Math.min(200,canvas.width*.4),canvas.height/2-Math.min(50,canvas.height*.1),Math.min(400,canvas.width*.8),Math.min(100,canvas.height*.2));ctx.fillStyle='white';ctx.font=`bold ${Math.min(canvas.width*.05,36)}px Arial`;ctx.textAlign='center';ctx.fillText('Level Complete!',canvas.width/2,canvas.height/2+(Math.min(canvas.width*.05,36))/3)}
        }

        let gameLoopRequest;
        function gameLoop(){if(!gameState.started){cancelAnimationFrame(gameLoopRequest);gameLoopRequest=null;return}updatePlayer();

        // Update background elements
        clouds.forEach(cloud => cloud.update());
        birds.forEach(bird => bird.update());
        magicalCreatures.forEach(creature => creature.update());

        for(let i=particles.length-1;i>=0;i--){particles[i].update();if(particles[i].life<=0||particles[i].size<=.5){particles.splice(i,1)}}draw();gameLoopRequest=requestAnimationFrame(gameLoop)}
        function drawStartScreenOverlay(){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(canvas.width*.15,canvas.height*.3,canvas.width*.7,canvas.height*.33);ctx.fillStyle='white';ctx.font=`bold ${canvas.width*.06}px Arial`;ctx.textAlign='center';ctx.fillText('Solfege Hero',canvas.width/2,canvas.height*.45);ctx.font=`${canvas.width*.03}px Arial`;ctx.fillText('Press "Start Game" to begin!',canvas.width/2,canvas.height*.55)}
        setCanvasSize();showInstructions();
        function lightenColor(c,p){const n=parseInt(String(c).replace('#',''),16),a=Math.round(2.55*p),R=(n>>16)+a,G=(n>>8&0xFF)+a,B=(n&0xFF)+a;return"#"+(0x1000000+(R<255?R<1?0:R:255)*0x10000+(G<255?G<1?0:G:255)*0x100+(B<255?B<1?0:B:255)).toString(16).slice(1)}
        function darkenColor(c,p){const n=parseInt(String(c).replace('#',''),16),a=Math.round(2.55*p),R=(n>>16)-a,G=(n>>8&0xFF)-a,B=(n&0xFF)-a;return"#"+(0x1000000+(R>0?R:0)*0x10000+(G>0?G:0)*0x100+(B>0?B:0)).toString(16).slice(1)}
    </script>
</body>
</html>
